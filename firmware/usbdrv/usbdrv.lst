   1               		.file	"usbdrv.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  98               	.global	usbSetInterrupt
 100               	usbSetInterrupt:
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8:usbdrv/usbdrv.c ****  * This Revision: $Id: usbdrv.c 791 2010-07-15 15:56:13Z cs $
   9:usbdrv/usbdrv.c ****  */
  10:usbdrv/usbdrv.c **** 
  11:usbdrv/usbdrv.c **** #include "usbportability.h"
  12:usbdrv/usbdrv.c **** #include "usbdrv.h"
  13:usbdrv/usbdrv.c **** #include "oddebug.h"
  14:usbdrv/usbdrv.c **** 
  15:usbdrv/usbdrv.c **** /*
  16:usbdrv/usbdrv.c **** General Description:
  17:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  18:usbdrv/usbdrv.c **** documentation of the entire driver.
  19:usbdrv/usbdrv.c **** */
  20:usbdrv/usbdrv.c **** 
  21:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  22:usbdrv/usbdrv.c **** 
  23:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  24:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  25:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  26:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  27:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  28:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  29:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  30:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  31:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  32:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  33:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  34:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  35:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  36:usbdrv/usbdrv.c **** #endif
  37:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  38:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  39:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  40:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  41:usbdrv/usbdrv.c **** #   endif
  42:usbdrv/usbdrv.c **** #endif
  43:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  44:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  45:usbdrv/usbdrv.c **** #endif
  46:usbdrv/usbdrv.c **** 
  47:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  48:usbdrv/usbdrv.c **** uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  49:usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  50:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
  51:usbdrv/usbdrv.c **** 
  52:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  53:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  54:usbdrv/usbdrv.c **** 
  55:usbdrv/usbdrv.c **** /*
  56:usbdrv/usbdrv.c **** optimizing hints:
  57:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  58:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  59:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  60:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  61:usbdrv/usbdrv.c **** */
  62:usbdrv/usbdrv.c **** 
  63:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  64:usbdrv/usbdrv.c **** 
  65:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  66:usbdrv/usbdrv.c **** 
  67:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  68:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  69:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  70:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorString0[] = { /* language descriptor */
  71:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  72:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  73:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  74:usbdrv/usbdrv.c **** };
  75:usbdrv/usbdrv.c **** #endif
  76:usbdrv/usbdrv.c **** 
  77:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  78:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  79:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  80:usbdrv/usbdrv.c **** PROGMEM int  usbDescriptorStringVendor[] = {
  81:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  82:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  83:usbdrv/usbdrv.c **** };
  84:usbdrv/usbdrv.c **** #endif
  85:usbdrv/usbdrv.c **** 
  86:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  87:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  88:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  89:usbdrv/usbdrv.c **** PROGMEM int  usbDescriptorStringDevice[] = {
  90:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  91:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  92:usbdrv/usbdrv.c **** };
  93:usbdrv/usbdrv.c **** #endif
  94:usbdrv/usbdrv.c **** 
  95:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  96:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  97:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  98:usbdrv/usbdrv.c **** PROGMEM int usbDescriptorStringSerialNumber[] = {
  99:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 100:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 101:usbdrv/usbdrv.c **** };
 102:usbdrv/usbdrv.c **** #endif
 103:usbdrv/usbdrv.c **** 
 104:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 105:usbdrv/usbdrv.c **** 
 106:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 107:usbdrv/usbdrv.c **** 
 108:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 109:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 110:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 111:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorDevice[] = {    /* USB device descriptor */
 112:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 113:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 114:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 116:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 117:usbdrv/usbdrv.c ****     0,                      /* protocol */
 118:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 119:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 120:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 121:usbdrv/usbdrv.c ****      */
 122:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 123:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 124:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 125:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 126:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 127:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 128:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 129:usbdrv/usbdrv.c **** };
 130:usbdrv/usbdrv.c **** #endif
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 133:usbdrv/usbdrv.c **** 
 134:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 135:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 136:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 137:usbdrv/usbdrv.c **** #endif
 138:usbdrv/usbdrv.c **** 
 139:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 140:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 141:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 142:usbdrv/usbdrv.c **** PROGMEM char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 143:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 144:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 145:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 146:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 147:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 148:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 149:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 150:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 151:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 152:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 153:usbdrv/usbdrv.c **** #else
 154:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 155:usbdrv/usbdrv.c **** #endif
 156:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 157:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 158:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 159:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 160:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 161:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 162:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 164:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
 165:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 166:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 167:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 168:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 169:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 170:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 171:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 172:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 173:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 174:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 175:usbdrv/usbdrv.c **** #endif
 176:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 177:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 178:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 179:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 180:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 181:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 182:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 183:usbdrv/usbdrv.c **** #endif
 184:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 185:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 186:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 187:usbdrv/usbdrv.c ****     (char)(0x80 | USB_CFG_EP3_NUMBER), /* IN endpoint number 3 */
 188:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 189:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 190:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 191:usbdrv/usbdrv.c **** #endif
 192:usbdrv/usbdrv.c **** };
 193:usbdrv/usbdrv.c **** #endif
 194:usbdrv/usbdrv.c **** 
 195:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 196:usbdrv/usbdrv.c **** 
 197:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 198:usbdrv/usbdrv.c **** {
 199:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 201:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 202:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 203:usbdrv/usbdrv.c **** #   endif
 204:usbdrv/usbdrv.c **** #endif
 205:usbdrv/usbdrv.c **** }
 206:usbdrv/usbdrv.c **** 
 207:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 208:usbdrv/usbdrv.c **** {
 209:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 210:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 211:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 212:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 213:usbdrv/usbdrv.c **** #endif
 214:usbdrv/usbdrv.c **** #endif
 215:usbdrv/usbdrv.c **** }
 216:usbdrv/usbdrv.c **** 
 217:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 218:usbdrv/usbdrv.c **** 
 219:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 220:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 221:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
 222:usbdrv/usbdrv.c **** {
 223:usbdrv/usbdrv.c **** uchar   *p;
 224:usbdrv/usbdrv.c **** char    i;
 225:usbdrv/usbdrv.c **** 
 226:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 227:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 228:usbdrv/usbdrv.c ****         return;
 229:usbdrv/usbdrv.c **** #endif
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 232:usbdrv/usbdrv.c ****     }else{
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 234:usbdrv/usbdrv.c ****     }
 235:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 236:usbdrv/usbdrv.c ****     i = len;
 237:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 242:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 243:usbdrv/usbdrv.c **** }
 244:usbdrv/usbdrv.c **** 
 245:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 246:usbdrv/usbdrv.c **** {
 102               	.LM0:
 103               	.LFBB1:
 104 0000 1F93      		push r17
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 107               	/* stack size = 1 */
 108               	.L__stack_usage = 1
 109 0002 162F      		mov r17,r22
 110               	.LBB63:
 111               	.LBB64:
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 113               	.LM1:
 114 0004 2091 0000 		lds r18,usbTxStatus1
 115 0008 24FF      		sbrs r18,4
 116 000a 00C0      		rjmp .L2
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 118               	.LM2:
 119 000c 2091 0000 		lds r18,usbTxStatus1+1
 120 0010 38E8      		ldi r19,lo8(-120)
 121 0012 2327      		eor r18,r19
 122 0014 2093 0000 		sts usbTxStatus1+1,r18
 123 0018 00C0      		rjmp .L3
 124               	.L2:
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 126               	.LM3:
 127 001a 2AE5      		ldi r18,lo8(90)
 128 001c 2093 0000 		sts usbTxStatus1,r18
 129               	.L3:
 130 0020 DC01      		movw r26,r24
 245:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 132               	.LM4:
 133 0022 812F      		mov r24,r17
 134 0024 8150      		subi r24,lo8(-(-1))
 135 0026 90E0      		ldi r25,lo8(0)
 136 0028 8050      		subi r24,lo8(-(usbTxStatus1+3))
 137 002a 9040      		sbci r25,hi8(-(usbTxStatus1+3))
 138               	.LBE64:
 139               	.LBE63:
 140 002c E0E0      		ldi r30,lo8(usbTxStatus1+2)
 141 002e F0E0      		ldi r31,hi8(usbTxStatus1+2)
 142               	.L4:
 143               	.LBB66:
 144               	.LBB65:
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 146               	.LM5:
 147 0030 2D91      		ld r18,X+
 148 0032 2193      		st Z+,r18
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 150               	.LM6:
 151 0034 E817      		cp r30,r24
 152 0036 F907      		cpc r31,r25
 153 0038 01F4      		brne .L4
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 155               	.LM7:
 156 003a 80E0      		ldi r24,lo8(usbTxStatus1+2)
 157 003c 90E0      		ldi r25,hi8(usbTxStatus1+2)
 158 003e 612F      		mov r22,r17
 159 0040 00D0      		rcall usbCrc16Append
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 161               	.LM8:
 162 0042 1C5F      		subi r17,lo8(-(4))
 163 0044 1093 0000 		sts usbTxStatus1,r17
 164               	/* epilogue start */
 165               	.LBE65:
 166               	.LBE66:
 247:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 248:usbdrv/usbdrv.c **** }
 168               	.LM9:
 169 0048 1F91      		pop r17
 170 004a 0895      		ret
 178               	.Lscope1:
 180               	.global	usbPoll
 182               	usbPoll:
 249:usbdrv/usbdrv.c **** #endif
 250:usbdrv/usbdrv.c **** 
 251:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 252:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 253:usbdrv/usbdrv.c **** {
 254:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 255:usbdrv/usbdrv.c **** }
 256:usbdrv/usbdrv.c **** #endif
 257:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 258:usbdrv/usbdrv.c **** 
 259:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 260:usbdrv/usbdrv.c **** 
 261:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 262:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 263:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 264:usbdrv/usbdrv.c ****  * cases.
 265:usbdrv/usbdrv.c ****  */
 266:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 267:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 268:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 269:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 270:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 271:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 272:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 273:usbdrv/usbdrv.c **** #else
 274:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 275:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 276:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 277:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 278:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 279:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 280:usbdrv/usbdrv.c **** #endif
 281:usbdrv/usbdrv.c **** 
 282:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 283:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 284:usbdrv/usbdrv.c **** #endif
 285:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 286:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 287:usbdrv/usbdrv.c **** #endif
 288:usbdrv/usbdrv.c **** 
 289:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 290:usbdrv/usbdrv.c **** 
 291:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 292:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 293:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 294:usbdrv/usbdrv.c ****  * optimizing!
 295:usbdrv/usbdrv.c ****  */
 296:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 297:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 298:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 299:usbdrv/usbdrv.c ****             flags = 0;                              \
 300:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 301:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 302:usbdrv/usbdrv.c ****         }else{                                      \
 303:usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 304:usbdrv/usbdrv.c ****             usbMsgPtr = (uchar *)(staticName);      \
 305:usbdrv/usbdrv.c ****         }                                           \
 306:usbdrv/usbdrv.c ****     }
 307:usbdrv/usbdrv.c **** 
 308:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 309:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 310:usbdrv/usbdrv.c ****  */
 311:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 312:usbdrv/usbdrv.c **** {
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 314:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 315:usbdrv/usbdrv.c **** 
 316:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 322:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 323:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 324:usbdrv/usbdrv.c ****             flags = 0;
 325:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 326:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 327:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 334:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 335:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 336:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 337:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 338:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 339:usbdrv/usbdrv.c ****             }
 340:usbdrv/usbdrv.c ****         SWITCH_END
 341:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 342:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 346:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 347:usbdrv/usbdrv.c **** #endif
 348:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 349:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 350:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 351:usbdrv/usbdrv.c ****         }
 352:usbdrv/usbdrv.c ****     SWITCH_END
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 354:usbdrv/usbdrv.c ****     return len;
 355:usbdrv/usbdrv.c **** }
 356:usbdrv/usbdrv.c **** 
 357:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 358:usbdrv/usbdrv.c **** 
 359:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 360:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 361:usbdrv/usbdrv.c ****  */
 362:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 363:usbdrv/usbdrv.c **** {
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 366:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 367:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
 368:usbdrv/usbdrv.c **** #endif
 369:usbdrv/usbdrv.c **** 
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 373:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 374:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 375:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 376:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 377:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 378:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 379:usbdrv/usbdrv.c **** #endif
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 381:usbdrv/usbdrv.c ****         len = 2;
 382:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 383:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 384:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 385:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 386:usbdrv/usbdrv.c ****             usbResetDataToggling();
 387:usbdrv/usbdrv.c ****         }
 388:usbdrv/usbdrv.c **** #endif
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 391:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 393:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 394:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 397:usbdrv/usbdrv.c ****         len = 1;
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 400:usbdrv/usbdrv.c ****         usbResetStall();
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 402:usbdrv/usbdrv.c ****         len = 1;
 403:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 405:usbdrv/usbdrv.c ****         usbResetDataToggling();
 406:usbdrv/usbdrv.c ****         usbResetStall();
 407:usbdrv/usbdrv.c **** #endif
 408:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 409:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 410:usbdrv/usbdrv.c ****     SWITCH_END
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 412:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 413:usbdrv/usbdrv.c ****     return len;
 414:usbdrv/usbdrv.c **** }
 415:usbdrv/usbdrv.c **** 
 416:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 417:usbdrv/usbdrv.c **** 
 418:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 419:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 420:usbdrv/usbdrv.c ****  * them accordingly.
 421:usbdrv/usbdrv.c ****  */
 422:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 423:usbdrv/usbdrv.c **** {
 424:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
 425:usbdrv/usbdrv.c **** 
 426:usbdrv/usbdrv.c **** /* usbRxToken can be:
 427:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 428:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 429:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 430:usbdrv/usbdrv.c ****  */
 431:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 432:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 433:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 434:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 435:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 436:usbdrv/usbdrv.c ****         return;
 437:usbdrv/usbdrv.c ****     }
 438:usbdrv/usbdrv.c **** #endif
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 441:usbdrv/usbdrv.c ****             return;
 442:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 449:usbdrv/usbdrv.c ****         }else{
 450:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 451:usbdrv/usbdrv.c ****         }
 452:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 453:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 454:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 455:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 456:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 457:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 458:usbdrv/usbdrv.c ****                 }else{
 459:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 460:usbdrv/usbdrv.c ****                 }
 461:usbdrv/usbdrv.c ****             }
 462:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 463:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 464:usbdrv/usbdrv.c **** #endif
 465:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 466:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 467:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 468:usbdrv/usbdrv.c ****         }else{
 469:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 470:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 471:usbdrv/usbdrv.c ****         }
 472:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 473:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 474:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 475:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 476:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 477:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 478:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 479:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 480:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 481:usbdrv/usbdrv.c ****             }
 482:usbdrv/usbdrv.c ****         }
 483:usbdrv/usbdrv.c **** #endif
 484:usbdrv/usbdrv.c ****     }
 485:usbdrv/usbdrv.c **** }
 486:usbdrv/usbdrv.c **** 
 487:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 488:usbdrv/usbdrv.c **** 
 489:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 490:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 491:usbdrv/usbdrv.c ****  */
 492:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 493:usbdrv/usbdrv.c **** {
 494:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 495:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 496:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 497:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 498:usbdrv/usbdrv.c ****         }else
 499:usbdrv/usbdrv.c **** #endif
 500:usbdrv/usbdrv.c ****         {
 501:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 503:usbdrv/usbdrv.c ****                 do{
 504:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 506:usbdrv/usbdrv.c ****                     r++;
 507:usbdrv/usbdrv.c ****                 }while(--i);
 508:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 509:usbdrv/usbdrv.c ****                 do{
 510:usbdrv/usbdrv.c ****                     *data++ = *r++;
 511:usbdrv/usbdrv.c ****                 }while(--i);
 512:usbdrv/usbdrv.c ****             }
 513:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 514:usbdrv/usbdrv.c ****         }
 515:usbdrv/usbdrv.c ****     }
 516:usbdrv/usbdrv.c ****     return len;
 517:usbdrv/usbdrv.c **** }
 518:usbdrv/usbdrv.c **** 
 519:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 520:usbdrv/usbdrv.c **** 
 521:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 522:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 523:usbdrv/usbdrv.c ****  */
 524:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 525:usbdrv/usbdrv.c **** {
 526:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 527:usbdrv/usbdrv.c **** uchar       len;
 528:usbdrv/usbdrv.c **** 
 529:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 530:usbdrv/usbdrv.c ****     if(wantLen > 8)
 531:usbdrv/usbdrv.c ****         wantLen = 8;
 532:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 534:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 535:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 540:usbdrv/usbdrv.c ****     }else{
 541:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 542:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 543:usbdrv/usbdrv.c ****     }
 544:usbdrv/usbdrv.c ****     usbTxLen = len;
 545:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 546:usbdrv/usbdrv.c **** }
 547:usbdrv/usbdrv.c **** 
 548:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 549:usbdrv/usbdrv.c **** 
 550:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 551:usbdrv/usbdrv.c **** {
 552:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 553:usbdrv/usbdrv.c **** static uchar    wasReset;
 554:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 555:usbdrv/usbdrv.c **** 
 556:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 557:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 558:usbdrv/usbdrv.c ****         wasReset = isReset;
 559:usbdrv/usbdrv.c ****     }
 560:usbdrv/usbdrv.c **** #endif
 561:usbdrv/usbdrv.c **** }
 562:usbdrv/usbdrv.c **** 
 563:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 564:usbdrv/usbdrv.c **** 
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 566:usbdrv/usbdrv.c **** {
 184               	.LM10:
 185               	.LFBB2:
 186 004c 1F93      		push r17
 187 004e CF93      		push r28
 188 0050 DF93      		push r29
 189               	/* prologue: function */
 190               	/* frame size = 0 */
 191               	/* stack size = 3 */
 192               	.L__stack_usage = 3
 567:usbdrv/usbdrv.c **** schar   len;
 568:usbdrv/usbdrv.c **** uchar   i;
 569:usbdrv/usbdrv.c **** 
 570:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 194               	.LM11:
 195 0052 8091 0000 		lds r24,usbRxLen
 196 0056 8350      		subi r24,lo8(-(-3))
 571:usbdrv/usbdrv.c ****     if(len >= 0){
 198               	.LM12:
 199 0058 87FD      		sbrc r24,7
 200 005a 00C0      		rjmp .L7
 572:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 573:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 574:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 575:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 576:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 577:usbdrv/usbdrv.c ****  */
 578:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 202               	.LM13:
 203 005c 9091 0000 		lds r25,usbInputBufOffset
 204               	.LBB67:
 205               	.LBB70:
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 207               	.LM14:
 208 0060 2091 0000 		lds r18,usbRxToken
 209 0064 2D32      		cpi r18,lo8(45)
 210 0066 01F0      		breq .+2
 211 0068 00C0      		rjmp .L8
 212               	.LBB73:
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 214               	.LM15:
 215 006a 8830      		cpi r24,lo8(8)
 216 006c 01F0      		breq .+2
 217 006e 00C0      		rjmp .L8
 218               	.LBE73:
 219               	.LBE70:
 220               	.LBE67:
 222               	.LM16:
 223 0070 CCE0      		ldi r28,lo8(12)
 224 0072 D0E0      		ldi r29,hi8(12)
 225 0074 C91B      		sub r28,r25
 226 0076 D109      		sbc r29,__zero_reg__
 227 0078 C050      		subi r28,lo8(-(usbRxBuf))
 228 007a D040      		sbci r29,hi8(-(usbRxBuf))
 229               	.LBB105:
 230               	.LBB69:
 231               	.LBB72:
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 233               	.LM17:
 234 007c 83EC      		ldi r24,lo8(-61)
 235 007e 8093 0000 		sts usbTxBuf,r24
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 237               	.LM18:
 238 0082 8AE5      		ldi r24,lo8(90)
 239 0084 8093 0000 		sts usbTxLen,r24
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 241               	.LM19:
 242 0088 1092 0000 		sts usbMsgFlags,__zero_reg__
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 244               	.LM20:
 245 008c 8881      		ld r24,Y
 246 008e 8076      		andi r24,lo8(96)
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 248               	.LM21:
 249 0090 01F0      		breq .L9
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 251               	.LM22:
 252 0092 CE01      		movw r24,r28
 253 0094 00D0      		rcall usbFunctionSetup
 254 0096 00C0      		rjmp .L10
 255               	.L9:
 256               	.LBB75:
 257               	.LBB78:
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 259               	.LM23:
 260 0098 9A81      		ldd r25,Y+2
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 262               	.LM24:
 263 009a 1092 0000 		sts usbTxBuf+9,__zero_reg__
 264               	.LBB81:
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 266               	.LM25:
 267 009e 8981      		ldd r24,Y+1
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 269               	.LM26:
 270 00a0 8823      		tst r24
 271 00a2 01F4      		brne .L11
 272               	.LBB92:
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 274               	.LM27:
 275 00a4 1092 0000 		sts usbTxBuf+10,__zero_reg__
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 277               	.LM28:
 278 00a8 20E0      		ldi r18,lo8(usbTxBuf+9)
 279 00aa 30E0      		ldi r19,hi8(usbTxBuf+9)
 381:usbdrv/usbdrv.c ****         len = 2;
 281               	.LM29:
 282 00ac 82E0      		ldi r24,lo8(2)
 283 00ae 00C0      		rjmp .L12
 284               	.L11:
 285               	.LBE92:
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 287               	.LM30:
 288 00b0 8530      		cpi r24,lo8(5)
 289 00b2 01F4      		brne .L13
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 291               	.LM31:
 292 00b4 9093 0000 		sts usbNewDeviceAddr,r25
 293 00b8 00C0      		rjmp .L42
 294               	.L13:
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 296               	.LM32:
 297 00ba 8630      		cpi r24,lo8(6)
 298 00bc 01F0      		breq .+2
 299 00be 00C0      		rjmp .L14
 300               	.LBE81:
 301               	.LBE78:
 579:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 580:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 581:usbdrv/usbdrv.c ****             usbRxLen = 0;
 582:usbdrv/usbdrv.c **** #else
 583:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 584:usbdrv/usbdrv.c **** #endif
 585:usbdrv/usbdrv.c ****     }
 586:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 587:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 588:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 589:usbdrv/usbdrv.c ****         }
 590:usbdrv/usbdrv.c ****     }
 591:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 593:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 594:usbdrv/usbdrv.c ****             goto isNotReset;
 595:usbdrv/usbdrv.c ****     }
 596:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 597:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 598:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 599:usbdrv/usbdrv.c ****     usbResetStall();
 600:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 601:usbdrv/usbdrv.c **** isNotReset:
 602:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 603:usbdrv/usbdrv.c **** }
 604:usbdrv/usbdrv.c **** 
 605:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 606:usbdrv/usbdrv.c **** 
 607:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
 608:usbdrv/usbdrv.c **** {
 609:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 610:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 611:usbdrv/usbdrv.c **** #endif
 612:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 613:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 614:usbdrv/usbdrv.c **** #endif
 615:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 616:usbdrv/usbdrv.c ****     usbResetDataToggling();
 617:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 618:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 619:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 620:usbdrv/usbdrv.c ****     usbTxLen3 = USBPID_NAK;
 621:usbdrv/usbdrv.c **** #endif
 622:usbdrv/usbdrv.c **** #endif
 623:usbdrv/usbdrv.c **** }
 303               	.LM33:
 304 00c0 8B81      		ldd r24,Y+3
 305               	.LBB77:
 306               	.LBB80:
 307               	.LBB88:
 308               	.LBB89:
 309               	.LBB90:
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 311               	.LM34:
 312 00c2 8130      		cpi r24,lo8(1)
 313 00c4 01F4      		brne .L15
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 315               	.LM35:
 316 00c6 80E0      		ldi r24,lo8(usbDescriptorDevice)
 317 00c8 90E0      		ldi r25,hi8(usbDescriptorDevice)
 318 00ca 9093 0000 		sts usbMsgPtr+1,r25
 319 00ce 8093 0000 		sts usbMsgPtr,r24
 320 00d2 82E1      		ldi r24,lo8(18)
 321 00d4 00C0      		rjmp .L16
 322               	.L15:
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 324               	.LM36:
 325 00d6 8230      		cpi r24,lo8(2)
 326 00d8 01F4      		brne .L17
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 328               	.LM37:
 329 00da 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 330 00dc 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 331 00de 9093 0000 		sts usbMsgPtr+1,r25
 332 00e2 8093 0000 		sts usbMsgPtr,r24
 333 00e6 82E2      		ldi r24,lo8(34)
 334 00e8 00C0      		rjmp .L16
 335               	.L17:
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 337               	.LM38:
 338 00ea 8330      		cpi r24,lo8(3)
 339 00ec 01F4      		brne .L18
 340               	.LBB91:
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 342               	.LM39:
 343 00ee 9923      		tst r25
 344 00f0 01F4      		brne .L19
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 346               	.LM40:
 347 00f2 80E0      		ldi r24,lo8(usbDescriptorString0)
 348 00f4 90E0      		ldi r25,hi8(usbDescriptorString0)
 349 00f6 9093 0000 		sts usbMsgPtr+1,r25
 350 00fa 8093 0000 		sts usbMsgPtr,r24
 351 00fe 84E0      		ldi r24,lo8(4)
 352 0100 00C0      		rjmp .L16
 353               	.L19:
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 355               	.LM41:
 356 0102 9130      		cpi r25,lo8(1)
 357 0104 01F4      		brne .L20
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 359               	.LM42:
 360 0106 80E0      		ldi r24,lo8(usbDescriptorStringVendor)
 361 0108 90E0      		ldi r25,hi8(usbDescriptorStringVendor)
 362 010a 9093 0000 		sts usbMsgPtr+1,r25
 363 010e 8093 0000 		sts usbMsgPtr,r24
 364 0112 8EE0      		ldi r24,lo8(14)
 365 0114 00C0      		rjmp .L16
 366               	.L20:
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 368               	.LM43:
 369 0116 9230      		cpi r25,lo8(2)
 370 0118 01F4      		brne .L39
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 372               	.LM44:
 373 011a 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 374 011c 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 375 011e 9093 0000 		sts usbMsgPtr+1,r25
 376 0122 8093 0000 		sts usbMsgPtr,r24
 377 0126 84E1      		ldi r24,lo8(20)
 378 0128 00C0      		rjmp .L16
 379               	.L18:
 380               	.LBE91:
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 382               	.LM45:
 383 012a 8132      		cpi r24,lo8(33)
 384 012c 01F4      		brne .L21
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 386               	.LM46:
 387 012e 80E0      		ldi r24,lo8(usbDescriptorConfiguration+18)
 388 0130 90E0      		ldi r25,hi8(usbDescriptorConfiguration+18)
 389 0132 9093 0000 		sts usbMsgPtr+1,r25
 390 0136 8093 0000 		sts usbMsgPtr,r24
 391 013a 89E0      		ldi r24,lo8(9)
 392 013c 00C0      		rjmp .L16
 393               	.L21:
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 395               	.LM47:
 396 013e 8232      		cpi r24,lo8(34)
 397 0140 01F4      		brne .L39
 346:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 399               	.LM48:
 400 0142 80E0      		ldi r24,lo8(usbDescriptorHidReport)
 401 0144 90E0      		ldi r25,hi8(usbDescriptorHidReport)
 402 0146 9093 0000 		sts usbMsgPtr+1,r25
 403 014a 8093 0000 		sts usbMsgPtr,r24
 404 014e 86E1      		ldi r24,lo8(22)
 405 0150 00C0      		rjmp .L16
 406               	.L39:
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 408               	.LM49:
 409 0152 80E0      		ldi r24,lo8(0)
 410               	.L16:
 411               	.LBE90:
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 413               	.LM50:
 414 0154 90E4      		ldi r25,lo8(64)
 415 0156 9093 0000 		sts usbMsgFlags,r25
 416 015a 00C0      		rjmp .L10
 417               	.L14:
 418               	.LBE89:
 419               	.LBE88:
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 421               	.LM51:
 422 015c 8830      		cpi r24,lo8(8)
 423 015e 01F0      		breq .L40
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 425               	.LM52:
 426 0160 8930      		cpi r24,lo8(9)
 427 0162 01F4      		brne .L22
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 429               	.LM53:
 430 0164 9093 0000 		sts usbConfiguration,r25
 431 0168 00C0      		rjmp .L42
 432               	.L22:
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 434               	.LM54:
 435 016a 8A30      		cpi r24,lo8(10)
 436 016c 01F0      		breq .L41
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 438               	.LM55:
 439 016e 8B30      		cpi r24,lo8(11)
 440 0170 01F4      		brne .L42
 441               	.LBB83:
 442               	.LBB85:
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 444               	.LM56:
 445 0172 8BE4      		ldi r24,lo8(75)
 446 0174 8093 0000 		sts usbTxStatus1+1,r24
 447 0178 00C0      		rjmp .L42
 448               	.L40:
 449               	.LBE85:
 450               	.LBE83:
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 452               	.LM57:
 453 017a 20E0      		ldi r18,lo8(usbConfiguration)
 454 017c 30E0      		ldi r19,hi8(usbConfiguration)
 455 017e 00C0      		rjmp .L46
 456               	.L41:
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 458               	.LM58:
 459 0180 20E0      		ldi r18,lo8(usbTxBuf+9)
 460 0182 30E0      		ldi r19,hi8(usbTxBuf+9)
 461               	.L46:
 402:usbdrv/usbdrv.c ****         len = 1;
 463               	.LM59:
 464 0184 81E0      		ldi r24,lo8(1)
 465 0186 00C0      		rjmp .L12
 466               	.L42:
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 468               	.LM60:
 469 0188 20E0      		ldi r18,lo8(usbTxBuf+9)
 470 018a 30E0      		ldi r19,hi8(usbTxBuf+9)
 471 018c 80E0      		ldi r24,lo8(0)
 472               	.L12:
 473               	.LBE80:
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 475               	.LM61:
 476 018e 3093 0000 		sts usbMsgPtr+1,r19
 477 0192 2093 0000 		sts usbMsgPtr,r18
 478               	.L10:
 479               	.LBE77:
 480               	.LBE75:
 466:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 482               	.LM62:
 483 0196 9F81      		ldd r25,Y+7
 484 0198 9923      		tst r25
 485 019a 01F4      		brne .L23
 486 019c 9E81      		ldd r25,Y+6
 487 019e 9817      		cp r25,r24
 488 01a0 00F4      		brsh .L23
 489 01a2 892F      		mov r24,r25
 490               	.L23:
 472:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 492               	.LM63:
 493 01a4 8093 0000 		sts usbMsgLen,r24
 494               	.L8:
 495               	.LBE72:
 496               	.LBE69:
 497               	.LBE105:
 583:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 499               	.LM64:
 500 01a8 1092 0000 		sts usbRxLen,__zero_reg__
 501               	.L7:
 586:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 503               	.LM65:
 504 01ac 8091 0000 		lds r24,usbTxLen
 505 01b0 84FF      		sbrs r24,4
 506 01b2 00C0      		rjmp .L25
 587:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 508               	.LM66:
 509 01b4 8091 0000 		lds r24,usbMsgLen
 510 01b8 8F3F      		cpi r24,lo8(-1)
 511 01ba 01F4      		brne .+2
 512 01bc 00C0      		rjmp .L25
 513 01be 182F      		mov r17,r24
 514 01c0 8930      		cpi r24,lo8(9)
 515 01c2 00F0      		brlo .L26
 516 01c4 18E0      		ldi r17,lo8(8)
 517               	.L26:
 518               	.LBB106:
 519               	.LBB108:
 532:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 521               	.LM67:
 522 01c6 811B      		sub r24,r17
 523 01c8 8093 0000 		sts usbMsgLen,r24
 533:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 525               	.LM68:
 526 01cc 8091 0000 		lds r24,usbTxBuf
 527 01d0 98E8      		ldi r25,lo8(-120)
 528 01d2 8927      		eor r24,r25
 529 01d4 8093 0000 		sts usbTxBuf,r24
 530               	.LBB110:
 531               	.LBB112:
 494:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 533               	.LM69:
 534 01d8 1123      		tst r17
 535 01da 01F0      		breq .L27
 536               	.LBB114:
 501:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 538               	.LM70:
 539 01dc 8091 0000 		lds r24,usbMsgPtr
 540 01e0 9091 0000 		lds r25,usbMsgPtr+1
 502:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 542               	.LM71:
 543 01e4 3091 0000 		lds r19,usbMsgFlags
 544 01e8 212F      		mov r18,r17
 545 01ea 2150      		subi r18,lo8(-(-1))
 546 01ec 36FF      		sbrs r19,6
 547 01ee 00C0      		rjmp .L28
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 549               	.LM72:
 550 01f0 30E0      		ldi r19,lo8(0)
 551 01f2 A901      		movw r20,r18
 552 01f4 4050      		subi r20,lo8(-(usbTxBuf+2))
 553 01f6 5040      		sbci r21,hi8(-(usbTxBuf+2))
 554               	.LBE114:
 555               	.LBE112:
 556               	.LBE110:
 557               	.LBE108:
 558               	.LBE106:
 559               	.LBB121:
 560               	.LBB103:
 561               	.LBB101:
 562               	.LBB99:
 563               	.LBB97:
 564               	.LBB95:
 565               	.LBB93:
 566               	.LBB86:
 567 01f8 FC01      		movw r30,r24
 568 01fa A0E0      		ldi r26,lo8(usbTxBuf+1)
 569 01fc B0E0      		ldi r27,hi8(usbTxBuf+1)
 570               	.L29:
 571               	.LBE86:
 572               	.LBE93:
 573               	.LBE95:
 574               	.LBE97:
 575               	.LBE99:
 576               	.LBE101:
 577               	.LBE103:
 578               	.LBE121:
 579               	.LBB122:
 580               	.LBB107:
 581               	.LBB109:
 582               	.LBB111:
 583               	.LBB113:
 584               	.LBB115:
 585               	.LBB116:
 504:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 587               	.LM73:
 588               	/* #APP */
 589               	 ;  504 "usbdrv/usbdrv.c" 1
 590 01fe 6491      		lpm r22, Z
 591               		
 592               	 ;  0 "" 2
 593               	/* #NOAPP */
 594               	.LBE116:
 505:usbdrv/usbdrv.c ****                     *data++ = c;
 596               	.LM74:
 597 0200 6D93      		st X+,r22
 506:usbdrv/usbdrv.c ****                     r++;
 599               	.LM75:
 600 0202 3196      		adiw r30,1
 601               	.LBE115:
 507:usbdrv/usbdrv.c ****                 }while(--i);
 603               	.LM76:
 604 0204 A417      		cp r26,r20
 605 0206 B507      		cpc r27,r21
 606 0208 01F4      		brne .L29
 607 020a 00C0      		rjmp .L47
 608               	.L28:
 609 020c DC01      		movw r26,r24
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 611               	.LM77:
 612 020e 30E0      		ldi r19,lo8(0)
 613 0210 A901      		movw r20,r18
 614 0212 4050      		subi r20,lo8(-(usbTxBuf+2))
 615 0214 5040      		sbci r21,hi8(-(usbTxBuf+2))
 616               	.LBE113:
 617               	.LBE111:
 618               	.LBE109:
 619               	.LBE107:
 620               	.LBE122:
 621               	.LBB123:
 622               	.LBB68:
 623               	.LBB71:
 624               	.LBB74:
 625               	.LBB76:
 626               	.LBB79:
 627               	.LBB82:
 628               	.LBB84:
 629 0216 E0E0      		ldi r30,lo8(usbTxBuf+1)
 630 0218 F0E0      		ldi r31,hi8(usbTxBuf+1)
 631               	.L31:
 632               	.LBE84:
 633               	.LBE82:
 634               	.LBE79:
 635               	.LBE76:
 636               	.LBE74:
 637               	.LBE71:
 638               	.LBE68:
 639               	.LBE123:
 640               	.LBB124:
 641               	.LBB120:
 642               	.LBB119:
 643               	.LBB118:
 644               	.LBB117:
 510:usbdrv/usbdrv.c ****                     *data++ = *r++;
 646               	.LM78:
 647 021a 6D91      		ld r22,X+
 648 021c 6193      		st Z+,r22
 511:usbdrv/usbdrv.c ****                 }while(--i);
 650               	.LM79:
 651 021e E417      		cp r30,r20
 652 0220 F507      		cpc r31,r21
 653 0222 01F4      		brne .L31
 654               	.L47:
 565:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 656               	.LM80:
 657 0224 2F5F      		subi r18,lo8(-(1))
 658 0226 3F4F      		sbci r19,hi8(-(1))
 511:usbdrv/usbdrv.c ****                 }while(--i);
 660               	.LM81:
 661 0228 280F      		add r18,r24
 662 022a 391F      		adc r19,r25
 513:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 664               	.LM82:
 665 022c 3093 0000 		sts usbMsgPtr+1,r19
 666 0230 2093 0000 		sts usbMsgPtr,r18
 667               	.L27:
 668               	.LBE117:
 669               	.LBE118:
 670               	.LBE119:
 536:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 672               	.LM83:
 673 0234 80E0      		ldi r24,lo8(usbTxBuf+1)
 674 0236 90E0      		ldi r25,hi8(usbTxBuf+1)
 675 0238 612F      		mov r22,r17
 676 023a 00D0      		rcall usbCrc16Append
 537:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 678               	.LM84:
 679 023c 1C5F      		subi r17,lo8(-(4))
 538:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 681               	.LM85:
 682 023e 1C30      		cpi r17,lo8(12)
 683 0240 01F0      		breq .L32
 539:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 685               	.LM86:
 686 0242 8FEF      		ldi r24,lo8(-1)
 687 0244 8093 0000 		sts usbMsgLen,r24
 688               	.L32:
 544:usbdrv/usbdrv.c ****     usbTxLen = len;
 690               	.LM87:
 691 0248 1093 0000 		sts usbTxLen,r17
 692               	.L25:
 693               	.LBE120:
 694               	.LBE124:
 695               	.LBB125:
 696               	.LBB104:
 697               	.LBB102:
 698               	.LBB100:
 699               	.LBB98:
 700               	.LBB96:
 701               	.LBB94:
 702               	.LBB87:
 591:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 704               	.LM88:
 705 024c 84E1      		ldi r24,lo8(20)
 706               	.L34:
 707               	.LBE87:
 708               	.LBE94:
 709               	.LBE96:
 710               	.LBE98:
 711               	.LBE100:
 712               	.LBE102:
 713               	.LBE104:
 714               	.LBE125:
 715               	.LBB126:
 592:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 717               	.LM89:
 718 024e 96B3      		in r25,54-32
 719 0250 9570      		andi r25,lo8(5)
 593:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 721               	.LM90:
 722 0252 01F4      		brne .L33
 723               	.LBE126:
 591:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 725               	.LM91:
 726 0254 8150      		subi r24,lo8(-(-1))
 727 0256 01F4      		brne .L34
 597:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 729               	.LM92:
 730 0258 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 598:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 732               	.LM93:
 733 025c 1092 0000 		sts usbDeviceAddr,__zero_reg__
 734               	.L33:
 735               	.LBB127:
 736               	.LBB128:
 554:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 738               	.LM94:
 739 0260 11E0      		ldi r17,lo8(1)
 740 0262 8111      		cpse r24,__zero_reg__
 741 0264 10E0      		ldi r17,lo8(0)
 742               	.L35:
 556:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 744               	.LM95:
 745 0266 8091 0000 		lds r24,wasReset.1532
 746 026a 8117      		cp r24,r17
 747 026c 01F0      		breq .L6
 557:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 749               	.LM96:
 750 026e 1123      		tst r17
 751 0270 01F4      		brne .L37
 752 0272 00D0      		rcall usbEventResetReady
 753               	.L37:
 558:usbdrv/usbdrv.c ****         wasReset = isReset;
 755               	.LM97:
 756 0274 1093 0000 		sts wasReset.1532,r17
 757               	.L6:
 758               	/* epilogue start */
 759               	.LBE128:
 760               	.LBE127:
 603:usbdrv/usbdrv.c **** }
 762               	.LM98:
 763 0278 DF91      		pop r29
 764 027a CF91      		pop r28
 765 027c 1F91      		pop r17
 766 027e 0895      		ret
 855               	.Lscope2:
 857               	.global	usbInit
 859               	usbInit:
 608:usbdrv/usbdrv.c **** {
 861               	.LM99:
 862               	.LFBB3:
 863               	/* prologue: function */
 864               	/* frame size = 0 */
 865               	/* stack size = 0 */
 866               	.L__stack_usage = 0
 610:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 868               	.LM100:
 869 0280 85B7      		in r24,85-32
 870 0282 8260      		ori r24,lo8(2)
 871 0284 85BF      		out 85-32,r24
 615:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 873               	.LM101:
 874 0286 8BB7      		in r24,91-32
 875 0288 8064      		ori r24,lo8(64)
 876 028a 8BBF      		out 91-32,r24
 877               	.LBB129:
 878               	.LBB130:
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 880               	.LM102:
 881 028c 8BE4      		ldi r24,lo8(75)
 882 028e 8093 0000 		sts usbTxStatus1+1,r24
 883               	.LBE130:
 884               	.LBE129:
 618:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 886               	.LM103:
 887 0292 8AE5      		ldi r24,lo8(90)
 888 0294 8093 0000 		sts usbTxStatus1,r24
 889               	/* epilogue start */
 891               	.LM104:
 892 0298 0895      		ret
 894               	.Lscope3:
 895               	.global	usbTxLen
 896               		.data
 899               	usbTxLen:
 900 0000 5A        		.byte	90
 901               	.global	usbDescriptorString0
 902               		.section	.progmem.data,"a",@progbits
 905               	usbDescriptorString0:
 906 0000 04        		.byte	4
 907 0001 03        		.byte	3
 908 0002 09        		.byte	9
 909 0003 04        		.byte	4
 910               	.global	usbDescriptorStringVendor
 913               	usbDescriptorStringVendor:
 914 0004 0E03      		.word	782
 915 0006 6400      		.word	100
 916 0008 6100      		.word	97
 917 000a 7600      		.word	118
 918 000c 6500      		.word	101
 919 000e 2E00      		.word	46
 920 0010 6800      		.word	104
 921               	.global	usbDescriptorStringDevice
 924               	usbDescriptorStringDevice:
 925 0012 1403      		.word	788
 926 0014 4C00      		.word	76
 927 0016 4500      		.word	69
 928 0018 4400      		.word	68
 929 001a 4300      		.word	67
 930 001c 7400      		.word	116
 931 001e 6C00      		.word	108
 932 0020 4800      		.word	72
 933 0022 4900      		.word	73
 934 0024 4400      		.word	68
 935               	.global	usbDescriptorDevice
 938               	usbDescriptorDevice:
 939 0026 12        		.byte	18
 940 0027 01        		.byte	1
 941 0028 10        		.byte	16
 942 0029 01        		.byte	1
 943 002a 00        		.byte	0
 944 002b 00        		.byte	0
 945 002c 00        		.byte	0
 946 002d 08        		.byte	8
 947 002e C0        		.byte	-64
 948 002f 16        		.byte	22
 949 0030 DF        		.byte	-33
 950 0031 05        		.byte	5
 951 0032 00        		.byte	0
 952 0033 02        		.byte	2
 953 0034 01        		.byte	1
 954 0035 02        		.byte	2
 955 0036 00        		.byte	0
 956 0037 01        		.byte	1
 957               	.global	usbDescriptorConfiguration
 960               	usbDescriptorConfiguration:
 961 0038 09        		.byte	9
 962 0039 02        		.byte	2
 963 003a 22        		.byte	34
 964 003b 00        		.byte	0
 965 003c 01        		.byte	1
 966 003d 01        		.byte	1
 967 003e 00        		.byte	0
 968 003f 80        		.byte	-128
 969 0040 14        		.byte	20
 970 0041 09        		.byte	9
 971 0042 04        		.byte	4
 972 0043 00        		.byte	0
 973 0044 00        		.byte	0
 974 0045 01        		.byte	1
 975 0046 03        		.byte	3
 976 0047 00        		.byte	0
 977 0048 00        		.byte	0
 978 0049 00        		.byte	0
 979 004a 09        		.byte	9
 980 004b 21        		.byte	33
 981 004c 01        		.byte	1
 982 004d 01        		.byte	1
 983 004e 00        		.byte	0
 984 004f 01        		.byte	1
 985 0050 22        		.byte	34
 986 0051 16        		.byte	22
 987 0052 00        		.byte	0
 988 0053 07        		.byte	7
 989 0054 05        		.byte	5
 990 0055 81        		.byte	-127
 991 0056 03        		.byte	3
 992 0057 08        		.byte	8
 993 0058 00        		.byte	0
 994 0059 64        		.byte	100
 995               		.comm usbMsgPtr,2,1
 996               		.comm usbRxToken,1,1
 997               		.comm usbConfiguration,1,1
 998               		.comm usbSofCount,1,1
 999               		.comm usbTxStatus1,12,1
 1000               		.comm usbRxBuf,22,1
 1001               		.comm usbInputBufOffset,1,1
 1002               		.comm usbDeviceAddr,1,1
 1003               		.comm usbNewDeviceAddr,1,1
 1004               		.comm usbRxLen,1,1
 1005               		.comm usbCurrentTok,1,1
 1006               		.comm usbTxBuf,11,1
 1007               		.data
 1010               	usbMsgLen:
 1011 0001 FF        		.byte	-1
 1012               		.lcomm usbMsgFlags,1
 1013               		.lcomm wasReset.1532,1
 1034               		.text
 1036               	.Letext0:
 1037               	.global __do_copy_data
 1038               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 usbdrv.c
     /tmp/ccq8oEK8.s:2      *ABS*:0000003f __SREG__
     /tmp/ccq8oEK8.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccq8oEK8.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccq8oEK8.s:5      *ABS*:00000034 __CCP__
     /tmp/ccq8oEK8.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccq8oEK8.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccq8oEK8.s:100    .text:00000000 usbSetInterrupt
                            *COM*:0000000c usbTxStatus1
     /tmp/ccq8oEK8.s:182    .text:0000004c usbPoll
                            *COM*:00000001 usbRxLen
                            *COM*:00000001 usbInputBufOffset
                            *COM*:00000001 usbRxToken
                            *COM*:00000016 usbRxBuf
                            *COM*:0000000b usbTxBuf
     /tmp/ccq8oEK8.s:899    .data:00000000 usbTxLen
                             .bss:00000000 usbMsgFlags
                            *COM*:00000001 usbNewDeviceAddr
     /tmp/ccq8oEK8.s:938    .progmem.data:00000026 usbDescriptorDevice
                            *COM*:00000002 usbMsgPtr
     /tmp/ccq8oEK8.s:960    .progmem.data:00000038 usbDescriptorConfiguration
     /tmp/ccq8oEK8.s:905    .progmem.data:00000000 usbDescriptorString0
     /tmp/ccq8oEK8.s:913    .progmem.data:00000004 usbDescriptorStringVendor
     /tmp/ccq8oEK8.s:924    .progmem.data:00000012 usbDescriptorStringDevice
                            *COM*:00000001 usbConfiguration
     /tmp/ccq8oEK8.s:1010   .data:00000001 usbMsgLen
                            *COM*:00000001 usbDeviceAddr
     /tmp/ccq8oEK8.s:1012   .bss:00000001 wasReset.1532
     /tmp/ccq8oEK8.s:859    .text:00000280 usbInit
                            *COM*:00000001 usbSofCount
                            *COM*:00000001 usbCurrentTok

UNDEFINED SYMBOLS
usbCrc16Append
usbFunctionSetup
usbDescriptorHidReport
usbEventResetReady
__do_copy_data
__do_clear_bss
